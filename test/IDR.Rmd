---
title: "Irreproducible discovery rate"
author: "[Michael Love](http://mikelove.github.io)"
output: html_document
---

We've discussed the [false discovery rate](multtest.html) 
and the [local false discovery](localfdr.html)
rate, which both involve the assumption of two groups of hypotheses in
the data: a set of null hypotheses, and a set of alternative
hypotheses. Here, I'd like to introduce a slightly different framework
for assigning probabilities to high-throughput data, which is called
the *irreproducible discovery rate*, or IDR. A reference for the IDR
is the article 
[Measuring reproducibility of high-throughput experiments](https://arxiv.org/abs/1110.4705)
by Qunhua Li, James B. Brown, Haiyan Huang, and Peter J. Bickel.

The main idea is to imagine we have two replicates for a
high-throughput experiment, each which produce some kind of score for
many thousands of locations in the genome, and such that higher scores
are more interesting for the investigators. Rather than trying to
define what constitutes a null distribution of scores, we ask a
different question: what is the probability that we see a high score
in one replicate, but that we would see a lower score if we repeat the
experiment. We essentially want a set of locations where the scores
are high and reproducibly so. We will see what this looks like in
practice, using ChIP-seq data, which is the kind of dataset that the
method was expressly designed to help with.

ChIP-seq is an experiment which tells us the location of proteins
bound to DNA along the genome. There are numerous software for
defining discrete regions, called "peaks", where the sequenced reads
stack up, which indicates a location where protein was frequently
bound to DNA, looking across the many cells that are pooled to perform
a ChIP-seq experiment. Each peak can be given a "score" as to how
certain we are that a protein may have been bound there, which relates
to the number of reads that stack up in the peak, and also takes into
account the "background" of reads. Typically, a control experiment is
performed without a specific antibody, and the number of reads for the
specific antibody ChIP-seq is compared relative to the number of reads
for the control experiment.

The ENCODE project produced many ChIP-seq experiments for various
proteins and across many cell lines. We will focus on a specific
experiment which is listed 
[here](https://www.encodeproject.org/experiments/ENCSR841NDX/).
This specific experiment is called "ELF1 ChIP-seq on human GM12878"
(immortalized cell line), which means that the protein of interest was
ELF1, and the experiment was performed on the GM12878 cell line.

The BED format is described [here](https://genome.ucsc.edu/FAQ/FAQformat.html#format12)

```{r echo=FALSE}
knitr::opts_chunk$set(cache=TRUE)
```

```{r}
url1 <- "https://www.encodeproject.org/files/ENCFF003ZKO/@@download/ENCFF003ZKO.bed.gz"
file1 <- "peaks_rep1.bed.gz"
if (!file.exists(file1)) download.file(url1, file1)
url2 <- "https://www.encodeproject.org/files/ENCFF093VDW/@@download/ENCFF093VDW.bed.gz"
file2 <- "peaks_rep2.bed.gz"
if (!file.exists(file2)) download.file(url2, file2)
```

```{r message=FALSE}
library(readr)
library(GenomicRanges)
df1 <- read_delim(file1, delim="\t", col_names=FALSE)
df2 <- read_delim(file2, delim="\t", col_names=FALSE)
peak1 <- GRanges(df1$X1, IRanges(df1$X2, df1$X3), score=df1$X7)
peak2 <- GRanges(df2$X1, IRanges(df2$X2, df2$X3), score=df2$X7)
peak1 <- keepStandardChromosomes(peak1, pruning.mode="coarse")
peak2 <- keepStandardChromosomes(peak2, pruning.mode="coarse")
```

```{r}
fo <- findOverlaps(peak1, peak2)
length(fo)
table(duplicated(from(fo)))
table(duplicated(to(fo)))
```

```{r}
fo <- as.data.frame(fo)
fo2 <- fo[!duplicated(fo$queryHits) & !duplicated(fo$subjectHits),]
```

```{r}
y1 <- peak1$score[fo2$queryHits]
y2 <- peak2$score[fo2$subjectHits]
plot(y1, y2, cex=.1)
plot(log10(y1), log10(y2), cex=.1)
```

```{r}
plot(rank(-y1), rank(-y2), cex=.1)
```

IDR is a package on CRAN, but it is no longer maintained. The authors
now maintain IDR as a python package.

```{r}
library(idr)
dat <- cbind(log10(y1), log10(y2))
dat <- dat[sample(nrow(dat),5000),]
system.time({ 
  res <- est.IDR(dat, mu=3, sigma=1, rho=.9, p=.5)
})
df <- data.frame(rep1=dat[,1],rep2=dat[,2],
                 rank1=rank(-dat[,1]),rank2=rank(-dat[,2]),
                 idr=res$idr)
```

```{r}
library(ggplot2)
ggplot(df, aes(rep1,rep2,col=idr)) + geom_point()
```

```{r}
ggplot(df, aes(rank1,rank2,col=idr)) + geom_point()
```
